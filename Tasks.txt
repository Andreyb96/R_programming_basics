1  Модуль 1: базовые структуры и понятия
	1.1 Введение в курс
		1.1.1 Получить навыки программирования и обработки данных ещё на одном ЯП. Говорят R создан для анализа данных)
	1.2 Переменные, глобальное окружение, справка
		1.2.1 ... является кросс-платформенным языком?; ... является интерпретируемым языком?; ... сочетает в себе несколько различных стилей (парадигм) программирования?; ... это язык с открытым исходным кодом?; ... легко расширяем?; ... имеет академическое происхождение?
		1.2.2 Как сделать воспроизводимый пример (reproducible example)?; Как отсортировать дата фрейм по колонкам?; Как нарисовать графики в стиле комиксов xkcd?; Как убрать из дата фрейма ряды, содержащие пропущенные значения (NA)?
		1.2.3 Справка не откроется: if -- зарезервированное слово, которое надо заключать в кавычки.
		1.2.4 fft
		1.2.5 ... сторонним эффектом (side effect)
		1.2.6 -1
	1.3 Векторы (часть 1)
		1.3.1 <- Оператор присваивания; <<- Оператор глобального присваивания; <= Меньше либо равно; ^ Возведение в степень; : Создание числовых векторов с шагом 1; / Деление
		1.3.2 некоторые функции и операторы действуют поэлементно.
		1.3.4 Логический (logical); Целочисленный (integer); Числа с плавающей точкой (numeric/double); Строковый (character)
		1.3.5 -1:1 -1 0 1; as.logical(-1:1) TRUE FALSE TRUE; as.character(as.logical(-1:1)) "TRUE" "FALSE" "TRUE"; as.numeric(as.logical(-1:1)) 1 0 1; as.character(as.numeric(as.logical(-1:1))) "1" "0" "1"; as.numeric(as.character(as.logical(-1:1))) "1" "0" "1"
		1.3.6 xXx_TerM1Nat0R_xXx; super_long_name_in_fact_so_long_i_cannot_stop_typing_please_help; .hidden
	1.4 Управляющие конструкции, работа с пакетами
		1.4.1 ifelse -- это векторизованный вариант if.; Не стоит использовать цикл for, если есть возможность использовать векторизацию.
		1.4.2 249644
		1.4.4 overview
		1.4.5 stats; zoo; xts; quantmod
		1.4.6 Название операционной системы; Подключённые пакеты, поставляемые с base; Пакеты, подключённые пользователем; Название локали для отображения текста ошибок и сообщений; Тип архитектуры платформы (32-bit, 64-bit); Версию языка R
	1.5 Векторы (часть 2)
		1.5.1 x[-(1:floor(length(x)/7) * 7)]; x[-(seq(7, length(x), by = 7))]; x[1:length(x) %% 7 > 0]; x[1:length(x) %% 7 != 0]; x[c(rep(T, 6), F)]
		1.5.2 Совместима с числовым, логическим и строковым типом (для строкового типа производится попытка приведения к числовому типу ; если это удаётся, то результат имеет числовой тип) which.max; Совместима с числовым, логическим и строковым типом (для строкового типа нет неявного приведения, т.е. результат также имеет строковый тип) max; Предназначена только для логического типа векторов which; Длина результата может быть больше единицы (т.е. результат -- вектор произвольной длины) which
		1.5.3 6
		1.5.4 awesome
		1.5.6 Отрицательное - Способ целочисленного индексирования, для которого длина результата редко когда равна длине индекса; Положительное - Способ целочисленного индексирования, для которого длина результата всегда равна длине индекса; Логическое - Единственный способ, для которого работают правила переписывания; По именам - Способ, при котором отсутствие совпадения ведёт к созданию NA
		1.5.8 Вектор, функция; Основные типы векторов; Правила переписывания; Глобальное и локальное окружение
2 Модуль 2: продвинутые структуры
	2.1 Матрицы и списки
		2.1.1 mat[m, n] - Вектор длины 1, содержащий элемент в правом нижнем углу; mat[n, m] - Скорее всего, ошибочная запись: ошибки не будет только при m=n; mat[m, ] - Вектор, содержащий строку (ряд) номер m; mat[m, , drop = FALSE] - Матрица, состоящая из одной строки (ряда) номер m; mat[, n, drop = F] - Матрица, состоящая из одного столбца (колонки) номер n; mat[, n, drop = TRUE] - Вектор, содержащий столбец (колонку) номер n; mat > 5 - Матрица m на n логического типа по условию; mat[mat > 5] - Вектор, содержащий все значения по условию (возможно, пустой)
		2.1.4 Если x -- положительное число, то возвращаемое значение -- единичная матрица указанного размера; Если x -- вектор хотя бы из двух элементов, то возвращаемое значение -- диагональная матрица с указанными элементами на диагонали; Если x -- матрица, то возвращаемое значение -- вектор, содержащий диагональные элементы
		2.1.6 Все из вышеперечисленных (хотя apply здесь ужасен, а двойной цикл for дважды ужасен)
		2.1.7 Liberte Tower, 10, 170
	2.2 Дата фреймы
		2.2.1 Столбцы могут иметь разный тип - Верно; Функция length возвращает общее количество элементов - Неверно; Определена индексация как в стиле матриц, так и в стиле списков - Верно; По умолчанию схлопывание размерности отключено, т.е. не нужно указывать drop = FALSE - Неверно	
		2.2.2 Такая операция определена корректно: сработает автоматическое приведение типов
		2.2.3 29
		2.2.4 subset(sel = -rating, sub = rating < 50, attitude); subset(attitude, rating < 50, -rating); attitude[attitude$rating < 50, names(attitude) != "rating"]
		2.2.5 Количество станций, зарегистрировавших землетрясение, записанное третьим - 43; Максимальная сила землетрясений по шкале Рихтера - 6.4; Медианная глубина землетрясений (км) - 247; Количество станций, зарегистрировавших землетрясение, записанное предпоследним - 14; Средняя глубина землетрясений (км) - 311.371; Минимальная сила землетрясений по шкале Рихтера - 4
		2.2.6 9.57
		2.2.7 A (ольха); W (ива); DB (карликовая берёза); H (травяные растения); E (вереск); L (лишайники)
	2.3 Факторы и строки
		2.3.1 nchar
		2.3.2 paste0 -- это, по сути, paste с аргументом sep = ""?
		2.3.3 Количество слов "to" - 4; Количество слов, содержащих любую букву из "f", "q" и "w" - 7; Количество слов, содержащих букву "b", после которой -- любой другой символ - 5; Количество слов ровно из семи букв - 3
		2.3.4 str_split - library(stringr); strsplit - base R; str_detect - library(stringr); gsub - base R; str_replace - library(stringr); grep - base R
		2.3.5 По умолчанию опция stringsAsFactors равна TRUE; Нестрого говоря, фактор -- это целочисленный вектор плюс строковый вектор меток (уровней)
		2.3.6 [4.5, 5); [4, 4.5); [5, 5.5); [5.5, 6); [6, 6.5)
		2.3.7 McAdamCreek
		2.3.8 DB (карликовая берёза) - RA; W (ива) - JT; E (вереск) - JT; A (ольха) - JT; H (травяные растения) - JT; L (лишайники) - RA
3  Модуль 3: продвинутое программирование
	3.1 Функции
		3.1.1 seq(by = z, x, y); seq(y, z, fr = x); seq(x, y, z); seq(b = z, f = x, t = y); seq(to = y, by = z, from = x)
		3.1.3 paste("number", LETTERS[1:3], 1:6, sep = "_", collapse = " and ") - Многоточие как возможность указать произвольное количество аргументов; lapply(1:4, rnorm, mean = 10, sd = 10) - Многоточие как "проброс аргументов"; sort(rnorm(5)) - Использование аргументов по умолчанию; matrix(nrow = 3, ncol = 2, by = T, 0, dimn = NULL) - Использование правил разбора аргументов с частичным дополнением
		3.1.5 svd
		3.1.7 Разбираются аргументы по полному названию; Разбираются аргументы по префиксу; Разбираются аргументы по позиции; Неразобранные аргументы передаются в ellipsis (. . .)
	3.2 Элементы функционального программирования
		3.2.1 replicate - Запуск одного и того же выражения некоторое количество раз; mapply - Применение заданной функции к произвольному количеству векторов либо списков аргументов, в итерационном порядке; do.call - Применение заданной функции к списку аргументов; outer - Применение заданной функции к всевозможным комбинациям двух аргументов
		3.2.2 dapply
		3.2.3 игривый серый котёнок с умными глазами
		3.2.4 81
		3.2.5 matrix - summary; function - print, plot; default - print, summary, plot
		3.2.6 20, 11, 10, 1, 10, 1
		3.2.7 Сниппет m3 (бинарный оператор %o%); Сниппет m2 (функция vapply); Сниппет m1 (двойной for)
	3.3 Обработка данных при помощи dplyr
		3.3.1 Колонки tidy дата фрейма соответствуют переменным, ряды -- наблюдениям.
		3.3.2 select(df, contains("name"), date_added); df %>% select(c(1:2, 5)); select(df, matches("_.{4,5}$")); select(df, first_name, last_name, date_added)
		3.3.3 transmute - То же, что и mutate, но с удалением исходных колонок; sample_n - Дата фрейм, состоящий из случайных рядов исходного; inner_join - Объединение двух дата фреймов по ключу; берутся только значения по ключам, встречающимся в обоих дата фреймах; transform - Какой dplyr? Это же функция из base, не надо меня путать!
		3.3.4 Shift+M
		3.3.5 subset(avian, PDB > 0, c("Observer", "PDB")) - filter(select(avian, Observer, PDB), PDB > 0); aggregate(avian[, "PDB"], list(Observer = avian[, "Observer"]), function(x) sum(x > 0)) - summarise(group_by(avian, Observer), x = sum(PDB > 0)); avian[, "PDB"] <- avian[, "PDB"] > 0 - mutate(avian, PDB = PDB > 0)
		3.3.6 warpbreaks; group_by(wool, tension); summarise(avg = mean(breaks), max = max(breaks)); filter(avg > 25 | max > 42)
		3.3.7 CreteCreek, RR, H - меньше 100; McAdamCreek, RA, L - меньше 100; HortonCreek, RA, E - больше 100; LivingstonCreek, RR, W - больше 100; BunkerHill, JT, DB - меньше 100
	3.4 Заключение: что дальше?
		3.4.1 Иду заполнять!